<project default="import-code-from-repo" basedir="." xmlns:antcontrib="antlib:net.sf.antcontrib"
    xmlns:xmltask="antlib:com.oopsconsultancy.xmltask">

    <property file="build.properties" />

    <property name="repoLocation" value="C:/githere/" />
    <property name="packages_path_in_repo" value="${repoLocation}/assets/IS/packages" />
    <property name="properties_path_in_repo" value="${repoLocation}/assets/IS/properties" />
    <property name="packages-to-import" value="package_1,package_2" />
    <property name="server-host" value="localhost" />
    <property name="server-port" value="5555" />
    <property name="userid" value="Administrator" />
    <property name="password" value="manage" />
    <property name="webMethods.home" value="C:/SoftwareAG" />
    <property name="integration-server-packages" value="${webMethods.home}/IntegrationServer/packages" />

    <path id="classpath.ant">
        <fileset file="${webMethods.home}/common/lib/ant/ant-contrib-1.0b3.jar" />
    </path>

    <taskdef resource="net/sf/antcontrib/antcontrib.properties" uri="antlib:net.sf.antcontrib" classpathref="classpath.ant" />
    <taskdef uri="antlib:net.sf.antcontrib" resource="net/sf/antcontrib/antlib.xml" classpathref="classpath.ant" />

	<!-- Validate packages path and check if any packages (subdirectories) are available -->
	<target name="validate-packages-path">
		<!-- Check if the packages directory exists -->
		<available file="${packages_path_in_repo}" type="dir" property="packages.dir.exists" />
		<fail unless="packages.dir.exists">
			Directory ${packages_path_in_repo} does not exist. Please check the path and try again.
		</fail>

		<!-- Count the number of subdirectories (packages) in the directory -->
		<resourcecount property="package.count" when="greater" count="0">
			<dirset dir="${packages_path_in_repo}">
				<include name="*/" />
			</dirset>
		</resourcecount>

		<!-- Fail if no packages are found -->
		<fail message="No packages (subdirectories) found in ${packages_path_in_repo}. Please add packages before proceeding."
			unless="package.count" />
	</target>

    <!-- Ensure the Integration Server is up and running -->
    <target name="check-IS-running">
        <echo message="Checking if IS is up and running...http://${server-host}:${server-port}/invoke/wm.server/ping" />
        <waitfor maxwait="10" maxwaitunit="minute" checkevery="5" checkeveryunit="second">
            <http url="http://${server-host}:${server-port}/invoke/wm.server/ping" />
        </waitfor>
        <fail if="waitfor.failed">
            Integration Server is not running on ${server-host}:${server-port}. Please start IS before proceeding.
        </fail>
    </target>

	<!-- Check if the package already exists on IS -->
	<target name="check-package-exists">
		<echo message="Checking if package ${packageName} already exists on IS..." />
	
		<!-- Use curl to perform the HTTP request with Basic Authentication -->
		<exec executable="curl" failonerror="true">
			<arg value="-u" />
			<arg value="${userid}:${password}" />
			<arg value="http://${server-host}:${server-port}/invoke/wm.server.ns:getPackages" />
			<arg value="-o" />
			<arg value="./package-check-result.txt" />
		</exec>
	
		<!-- Load the contents of the file into a property -->
		<loadfile property="package.result" srcFile="./package-check-result.txt" />
	
		<!-- Check if the package name is present in the file contents using the contains task -->
		<condition property="package.exists">
			<contains string="${package.result}" substring="${packageName}" />
		</condition>
	
		<!-- Fail if the package already exists -->
		<fail message="Package ${packageName} already exists. Please delete it from IS and restart the server before proceeding."
			  if="package.exists" />
	
		<!-- Clean up the result file -->
		<delete file="./package-check-result.txt" />
	</target>

    <!-- Main import target with dependencies -->
    <target name="import-code-from-repo" depends="validate-packages-path,check-IS-running,import-properties">
        <dirset id="dist.contents" dir="${packages_path_in_repo}">
            <include name="*" />
        </dirset>
        <property name="webMethods.projects.filter" refid="dist.contents" />

        <antcontrib:for list="${webMethods.projects.filter}" delimiter=";" param="val">
            <sequential>
                <!-- Check if package exists before importing -->
                <antcall target="check-package-exists">
                    <param name="packageName" value="@{val}" />
                </antcall>

                <!-- Proceed with importing the package if it does not exist -->
                <antcall target="import-package">
                    <param name="packageName" value="@{val}" />
                </antcall>
            </sequential>
        </antcontrib:for>

        <antcontrib:for list="${webMethods.projects.filter}" delimiter=";" param="val">
            <sequential>
                <antcall target="activate-package">
                    <param name="packageName" value="@{val}" />
                </antcall>
            </sequential>
        </antcontrib:for>
    </target>

	<target name="interactive-install">
		<!-- Prompt the developer to proceed with installation -->
		<input addproperty="proceed" message="Do you want to install package ${packageName}? (yes/no)"/>
		<condition property="should.proceed" value="true">
			<equals arg1="${proceed}" arg2="yes"/>
		</condition>

		<!-- If the user chooses to proceed, call import-package -->
		<antcontrib:if>
			<condition>
				<isset property="should.proceed"/>
			</condition>
			<then>
				<antcall target="import-package">
					<param name="packageName" value="${packageName}" />
				</antcall>
			</then>
			<else>
				<echo message="Skipping package: ${packageName}"/>
			</else>
		</antcontrib:if>
	</target>

	<target name="import-package">
		<!-- Check the OS and set a property -->
		<condition property="os.is.windows" value="true">
			<os family="windows" />
		</condition>

		<condition property="os.is.mac" value="true">
			<os family="mac" />
		</condition>

		<!-- Echo the detected OS -->
		<antcontrib:if>
			<equals arg1="${os.is.windows}" arg2="true"/>
			<then>
				<echo message="Detected OS: Windows" />
				<antcall target="import-package-win">
					<param name="packageName" value="${packageName}" />
				</antcall>
			</then>
			<else>
				<echo message="Detected OS: macOS" />
				<antcall target="import-package-mac">
					<param name="packageName" value="${packageName}" />
				</antcall>
			</else>
		</antcontrib:if>
	</target>

	<target name="import-package-win">
		<echo message="Installing package: ${packageName} on Windows" />
		<echo message="Executing command: mklink /j ${integration-server-packages}\${packageName} ${repoLocation}\${packageName}" />
		<exec executable="cmd">
			<arg line="/c mklink /j ${integration-server-packages}\${packageName} ${repoLocation}\${packageName}" />
		</exec>
		<echo message="Executing command: ${integration-server-packages}\..\bin\jcode.bat make ${packageName}" />
		<exec executable="cmd">
			<arg line="/c ${integration-server-packages}\..\bin\jcode.bat make ${packageName}" />
		</exec>
	</target>

	<target name="import-package-mac">
		<echo message="Installing package: ${packageName} on macOS" />
		<echo message="Executing command: ln -s ${repoLocation}/${packageName} ${integration-server-packages}/${packageName}" />
		<!-- Create a symbolic link (equivalent to mklink /j on Windows) -->
		<exec executable="/bin/ln">
			<arg value="-s" />
			<arg value="${packages_path_in_repo}/${packageName}" />
			<arg value="${integration-server-packages}/${packageName}" />
		</exec>

		<echo message="Executing command: ${integration-server-packages}/../bin/jcode.sh make ${packageName}" />
		<!-- Execute the jcode.sh script (assuming it's a shell script on macOS) -->
		<exec executable="/bin/sh">
			<arg value="${integration-server-packages}/../bin/jcode.sh" />
			<arg value="make" />
			<arg value="${packageName}" />
		</exec>
	</target>

	<target name="activate-package">
		<get
			src="http://${server-host}:${server-port}/invoke/wm.server.packages:packageActivate?package=${packageName}"
			dest="./${packageName}.html" username="${userid}" password="${password}" />
		<get
			src="http://${server-host}:${server-port}/invoke/wm.server.packages:packageEnable?package=${packageName}"
			dest="./${packageName}.html" username="${userid}" password="${password}" />
		<get
			src="http://${server-host}:${server-port}/invoke/wm.server.packages:packageReload?package=${packageName}"
			dest="./${packageName}.html" username="${userid}" password="${password}" />
		<delete file="./${packageName}.html" />
	</target>

	<target name="import-properties">
		<!-- Declare property files location -->
		<property name="properties_path_in_repo" value="${repoLocation}/assets/IS/properties" />
		<property name="properties_target_path" value="${webMethods.home.properties}" />
	
		<!-- Check and create the target properties folder if not present -->
		<mkdir dir="${properties_target_path}" />
	
		<!-- Check if the properties folder exists in the repo -->
		<available file="${properties_path_in_repo}" type="dir" property="properties.folder.exists" />
		<fail unless="properties.folder.exists">
			The properties folder ${properties_path_in_repo} does not exist in the repo.
		</fail>
	
		<!-- Get user input for the environment selection (DV, IT, UA, PD) -->
		<input addproperty="PROP_FILES_ENV_TO_IMPORT" message="Select environment property files to import (DV, IT, UA, PD):" validargs="DV,IT,UA,PD" />
	
		<!-- Create a fileset for all environment-specific property files -->
		<fileset id="envPropertyFiles" dir="${properties_path_in_repo}">
			<include name="${PROP_FILES_ENV_TO_IMPORT}_*.*" />
		</fileset>
	
		<!-- List all files that will be processed for linking -->
		<echo message="The following files will be processed for creating symlinks:" />
		<pathconvert property="fileListToProcess" pathsep="${line.separator}">
			<fileset refid="envPropertyFiles" />
		</pathconvert>
		<echo message="${fileListToProcess}" />
	
		<!-- Iterate over each file and create symbolic links -->
		<apply executable="ln" parallel="false" osfamily="unix" failonerror="true">
			<fileset refid="envPropertyFiles" />
			<mapper type="regexp" from="${PROP_FILES_ENV_TO_IMPORT}_(.*)" to="${properties_target_path}/\1" />
			<arg value="-s" />
			<srcfile />
			<targetfile />
		</apply>
	
		<!-- Apply for Windows systems -->
		<apply executable="cmd" parallel="false" osfamily="windows" failonerror="true">
			<fileset refid="envPropertyFiles" />
			<mapper type="regexp" from="${PROP_FILES_ENV_TO_IMPORT}_(.*)" to="${properties_target_path}/\1" />
			<arg value="/c" />
			<arg value="mklink" />
			<srcfile />
			<targetfile />
		</apply>
	
		<!-- Output the linked files -->
		<echo message="Created symlinks for the selected environment's property files." />
	</target>

    
</project>
